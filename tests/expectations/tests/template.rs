/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


#[repr(C)]
#[derive(Debug)]
pub struct Foo<T> {
    pub m_member: T,
    pub m_member_ptr: *mut T,
    pub m_member_arr: [T; 1usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for Foo<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B<T> {
    pub m_member: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for B<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "_Z3bar3FooIiiE"]
    pub fn bar(foo: Foo<::std::os::raw::c_int>);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct C {
    pub mB: B<::std::os::raw::c_uint>,
    pub mBConstPtr: B<*const ::std::os::raw::c_int>,
    pub mBConst: B<::std::os::raw::c_int>,
    pub mBVolatile: B<::std::os::raw::c_int>,
    pub mBConstBool: B<bool>,
    pub mBConstChar: B<u16>,
    pub mBArray: B<[::std::os::raw::c_int; 1usize]>,
}
#[test]
fn bindgen_test_layout_C() {
    assert_eq!(::std::mem::size_of::<C>() , 32usize , concat ! (
               "Size of: " , stringify ! ( C ) ));
    assert_eq! (::std::mem::align_of::<C>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( C ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const C ) ) . mB as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBConstPtr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBConstPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBConst as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBConst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBVolatile as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBVolatile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBConstBool as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBConstBool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBConstChar as * const _ as usize
                } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBConstChar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const C ) ) . mBArray as * const _ as usize } ,
                28usize , concat ! (
                "Alignment of field: " , stringify ! ( C ) , "::" , stringify
                ! ( mBArray ) ));
}
impl Clone for C {
    fn clone(&self) -> Self { *self }
}
impl Default for C {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug)]
pub struct D {
    pub m_foo: D_MyFoo,
}
pub type D_MyFoo = Foo<::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug)]
pub struct D_U<Z> {
    pub m_nested_foo: D_MyFoo,
    pub m_baz: Z,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Z>>,
}
impl <Z> Default for D_U<Z> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Default for D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rooted<T> {
    pub prev: *mut T,
    pub next: *mut Rooted<*mut ::std::os::raw::c_void>,
    pub ptr: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for Rooted<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RootedContainer {
    pub root: Rooted<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_RootedContainer() {
    assert_eq!(::std::mem::size_of::<RootedContainer>() , 24usize , concat ! (
               "Size of: " , stringify ! ( RootedContainer ) ));
    assert_eq! (::std::mem::align_of::<RootedContainer>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( RootedContainer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RootedContainer ) ) . root as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RootedContainer ) ,
                "::" , stringify ! ( root ) ));
}
impl Clone for RootedContainer {
    fn clone(&self) -> Self { *self }
}
impl Default for RootedContainer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug)]
pub struct WithDtor<T> {
    pub member: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for WithDtor<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithDtorIntFwd = WithDtor<::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug)]
pub struct PODButContainsDtor {
    pub member: WithDtorIntFwd,
}
#[test]
fn bindgen_test_layout_PODButContainsDtor() {
    assert_eq!(::std::mem::size_of::<PODButContainsDtor>() , 4usize , concat !
               ( "Size of: " , stringify ! ( PODButContainsDtor ) ));
    assert_eq! (::std::mem::align_of::<PODButContainsDtor>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( PODButContainsDtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PODButContainsDtor ) ) . member as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PODButContainsDtor ) ,
                "::" , stringify ! ( member ) ));
}
impl Default for PODButContainsDtor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// <div rustbindgen opaque>
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Opaque {
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct POD {
    pub opaque_member: u32,
}
#[test]
fn bindgen_test_layout_POD() {
    assert_eq!(::std::mem::size_of::<POD>() , 4usize , concat ! (
               "Size of: " , stringify ! ( POD ) ));
    assert_eq! (::std::mem::align_of::<POD>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( POD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const POD ) ) . opaque_member as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( POD ) , "::" ,
                stringify ! ( opaque_member ) ));
}
impl Clone for POD {
    fn clone(&self) -> Self { *self }
}
/// <div rustbindgen replaces="NestedReplaced"></div>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedReplaced<T> {
    pub buff: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for NestedReplaced<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedBase<T> {
    pub buff: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for NestedBase<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Incomplete<T> {
    pub d: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for Incomplete<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedContainer<T> {
    pub c: T,
    pub nested: NestedReplaced<T>,
    pub inc: Incomplete<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for NestedContainer<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct Untemplated {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Untemplated() {
    assert_eq!(::std::mem::size_of::<Untemplated>() , 1usize , concat ! (
               "Size of: " , stringify ! ( Untemplated ) ));
    assert_eq! (::std::mem::align_of::<Untemplated>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( Untemplated ) ));
}
impl Clone for Untemplated {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Templated {
    pub m_untemplated: Untemplated,
}
/// If the replacement doesn't happen at the parse level the container would be
/// copy and the replacement wouldn't, so this wouldn't compile.
///
/// <div rustbindgen replaces="ReplacedWithoutDestructor"></div>
#[repr(C)]
#[derive(Debug)]
pub struct ReplacedWithoutDestructor<T> {
    pub buff: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for ReplacedWithoutDestructor<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug)]
pub struct ShouldNotBeCopiable<T> {
    pub m_member: ReplacedWithoutDestructor<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for ShouldNotBeCopiable<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug)]
pub struct ShouldNotBeCopiableAsWell<U> {
    pub m_member: ReplacedWithoutDestructorFwd<U>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<U>>,
}
impl <U> Default for ShouldNotBeCopiableAsWell<U> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// If the replacement doesn't happen at the parse level the container would be
/// copy and the replacement wouldn't, so this wouldn't compile.
///
/// <div rustbindgen replaces="ReplacedWithoutDestructorFwd"></div>
#[repr(C)]
#[derive(Debug)]
pub struct ReplacedWithoutDestructorFwd<T> {
    pub buff: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl <T> Default for ReplacedWithoutDestructorFwd<T> {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn __bindgen_test_layout_Foo_open0_int_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<Foo<::std::os::raw::c_int>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               Foo<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<Foo<::std::os::raw::c_int>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               Foo<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_unsigned_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<::std::os::raw::c_uint>>() , 4usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               B<::std::os::raw::c_uint> ) ));
    assert_eq!(::std::mem::align_of::<B<::std::os::raw::c_uint>>() , 4usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<::std::os::raw::c_uint> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_ptr_const_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<*const ::std::os::raw::c_int>>() ,
               8usize , concat ! (
               "Size of template specialization: " , stringify ! (
               B<*const ::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<B<*const ::std::os::raw::c_int>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<*const ::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_const_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<::std::os::raw::c_int>>() , 4usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               B<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<B<::std::os::raw::c_int>>() , 4usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_volatile_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<::std::os::raw::c_int>>() , 4usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               B<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<B<::std::os::raw::c_int>>() , 4usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_const_bool_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<bool>>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! ( B<bool> )
               ));
    assert_eq!(::std::mem::align_of::<B<bool>>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<bool> ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_const_char16_t_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<u16>>() , 2usize , concat ! (
               "Size of template specialization: " , stringify ! ( B<u16> )
               ));
    assert_eq!(::std::mem::align_of::<B<u16>>() , 2usize , concat ! (
               "Alignment of template specialization: " , stringify ! ( B<u16>
               ) ));
}
#[test]
fn __bindgen_test_layout_B_open0_array_int_1_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<B<[::std::os::raw::c_int; 1usize]>>() ,
               4usize , concat ! (
               "Size of template specialization: " , stringify ! (
               B<[::std::os::raw::c_int; 1usize]> ) ));
    assert_eq!(::std::mem::align_of::<B<[::std::os::raw::c_int; 1usize]>>() ,
               4usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               B<[::std::os::raw::c_int; 1usize]> ) ));
}
#[test]
fn __bindgen_test_layout_Foo_open0_int_int_close0_instantiation_1() {
    assert_eq!(::std::mem::size_of::<Foo<::std::os::raw::c_int>>() , 24usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               Foo<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<Foo<::std::os::raw::c_int>>() , 8usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               Foo<::std::os::raw::c_int> ) ));
}
#[test]
fn __bindgen_test_layout_Rooted_open0_ptr_void_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<Rooted<*mut ::std::os::raw::c_void>>() ,
               24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Rooted<*mut ::std::os::raw::c_void> ) ));
    assert_eq!(::std::mem::align_of::<Rooted<*mut ::std::os::raw::c_void>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Rooted<*mut ::std::os::raw::c_void> ) ));
}
#[test]
fn __bindgen_test_layout_Rooted_open0_ptr_void_close0_instantiation_1() {
    assert_eq!(::std::mem::size_of::<Rooted<*mut ::std::os::raw::c_void>>() ,
               24usize , concat ! (
               "Size of template specialization: " , stringify ! (
               Rooted<*mut ::std::os::raw::c_void> ) ));
    assert_eq!(::std::mem::align_of::<Rooted<*mut ::std::os::raw::c_void>>() ,
               8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               Rooted<*mut ::std::os::raw::c_void> ) ));
}
#[test]
fn __bindgen_test_layout_WithDtor_open0_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<WithDtor<::std::os::raw::c_int>>() ,
               4usize , concat ! (
               "Size of template specialization: " , stringify ! (
               WithDtor<::std::os::raw::c_int> ) ));
    assert_eq!(::std::mem::align_of::<WithDtor<::std::os::raw::c_int>>() ,
               4usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               WithDtor<::std::os::raw::c_int> ) ));
}
