/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleSVGOpacitySource {
    eStyleSVGOpacitySource_Normal = 0,
    eStyleSVGOpacitySource_ContextFillOpacity = 1,
    eStyleSVGOpacitySource_ContextStrokeOpacity = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Weird {
    pub mStrokeDasharrayLength: ::std::os::raw::c_uint,
    pub _bitfield_1: [u16; 2usize],
    pub mClipRule: ::std::os::raw::c_uchar,
    pub mColorInterpolation: ::std::os::raw::c_uchar,
    pub mColorInterpolationFilters: ::std::os::raw::c_uchar,
    pub mFillRule: ::std::os::raw::c_uchar,
    pub mImageRendering: ::std::os::raw::c_uchar,
    pub mPaintOrder: ::std::os::raw::c_uchar,
    pub mShapeRendering: ::std::os::raw::c_uchar,
    pub mStrokeLinecap: ::std::os::raw::c_uchar,
    pub mStrokeLinejoin: ::std::os::raw::c_uchar,
    pub mTextAnchor: ::std::os::raw::c_uchar,
    pub mTextRendering: ::std::os::raw::c_uchar,
    pub _bitfield_2: [u8; 2usize],
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_Weird() {
    assert_eq!(::std::mem::size_of::<Weird>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Weird ) ));
    assert_eq! (::std::mem::align_of::<Weird>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Weird ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mStrokeDasharrayLength as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mStrokeDasharrayLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mClipRule as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mClipRule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mColorInterpolation as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mColorInterpolation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mColorInterpolationFilters as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mColorInterpolationFilters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mFillRule as * const _ as
                usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mFillRule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mImageRendering as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mImageRendering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mPaintOrder as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mPaintOrder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mShapeRendering as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mShapeRendering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mStrokeLinecap as * const _
                as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mStrokeLinecap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mStrokeLinejoin as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mStrokeLinejoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mTextAnchor as * const _ as
                usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mTextAnchor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Weird ) ) . mTextRendering as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( Weird ) , "::" ,
                stringify ! ( mTextRendering ) ));
}
impl Clone for Weird {
    fn clone(&self) -> Self { *self }
}
impl Default for Weird {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Weird {
    #[inline]
    pub fn bitTest(&self) -> ::std::os::raw::c_uint {
        let mask = 65535usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bitTest(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65535usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn bitTest2(&self) -> ::std::os::raw::c_uint {
        let mask = 2147418112usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bitTest2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2147418112usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(bitTest: ::std::os::raw::c_uint,
                          bitTest2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((bitTest as u32 as u32) << 0usize) & (65535usize as u32))
         } | ((bitTest2 as u32 as u32) << 16usize) & (2147418112usize as u32))
    }
    #[inline]
    pub fn mFillOpacitySource(&self) -> nsStyleSVGOpacitySource {
        let mask = 7usize as u16;
        let unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mFillOpacitySource(&mut self, val: nsStyleSVGOpacitySource) {
        let mask = 7usize as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn mStrokeOpacitySource(&self) -> nsStyleSVGOpacitySource {
        let mask = 56usize as u16;
        let unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mStrokeOpacitySource(&mut self, val: nsStyleSVGOpacitySource) {
        let mask = 56usize as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn mStrokeDasharrayFromObject(&self) -> bool {
        let mask = 64usize as u16;
        let unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mStrokeDasharrayFromObject(&mut self, val: bool) {
        let mask = 64usize as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn mStrokeDashoffsetFromObject(&self) -> bool {
        let mask = 128usize as u16;
        let unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mStrokeDashoffsetFromObject(&mut self, val: bool) {
        let mask = 128usize as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn mStrokeWidthFromObject(&self) -> bool {
        let mask = 256usize as u16;
        let unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mStrokeWidthFromObject(&mut self, val: bool) {
        let mask = 256usize as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_2(mFillOpacitySource: nsStyleSVGOpacitySource,
                          mStrokeOpacitySource: nsStyleSVGOpacitySource,
                          mStrokeDasharrayFromObject: bool,
                          mStrokeDashoffsetFromObject: bool,
                          mStrokeWidthFromObject: bool) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((mFillOpacitySource as u32 as u16) <<
                                      0usize) & (7usize as u16))
                        } |
                            ((mStrokeOpacitySource as u32 as u16) << 3usize) &
                                (56usize as u16))
                   } |
                       ((mStrokeDasharrayFromObject as u8 as u16) << 6usize) &
                           (64usize as u16))
              } |
                  ((mStrokeDashoffsetFromObject as u8 as u16) << 7usize) &
                      (128usize as u16))
         } |
             ((mStrokeWidthFromObject as u8 as u16) << 8usize) &
                 (256usize as u16))
    }
}
